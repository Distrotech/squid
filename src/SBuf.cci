/*
 * SBuf.cc (C) 2008 Francesco Chemolli <kinkie@squid-cache.org>
 *
 * SQUID Web Proxy Cache          http://www.squid-cache.org/
 * ----------------------------------------------------------
 *
 *  Squid is the result of efforts by numerous individuals from
 *  the Internet community; see the CONTRIBUTORS file for full
 *  details.   Many organizations have provided support for Squid's
 *  development; see the SPONSORS file for full details.  Squid is
 *  Copyrighted (C) 2001 by the Regents of the University of
 *  California; see the COPYRIGHT file for full details.  Squid
 *  incorporates software developed and/or copyrighted by other
 *  sources; see the CREDITS file for full details.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
 */

#include "base/RefCount.h"
#include "Debug.h"
#include "OutOfBoundsException.h"
#include "SBufExceptions.h"

#if HAVE_CLIMITS
#include <climits>
#elif HAVE_LIMITS_H
#include <limits.h>
#endif

SBuf&
SBuf::operator =(const SBuf & S)
{
    return assign(S);
}

SBuf&
SBuf::operator =(const char *S)
{
    return assign(S);
}

bool
SBuf::operator <(const SBuf &S) const
{
    return (compare(S) < 0);
}

bool
SBuf::operator >(const SBuf &S) const
{
    return (compare(S) > 0);
}

bool
SBuf::operator <=(const SBuf &S) const
{
    return (compare(S) <= 0);
}

bool
SBuf::operator >=(const SBuf &S) const
{
    return (compare(S) >= 0);
}

SBuf::size_type
SBuf::length() const
{
    return len_;
}

int
SBuf::plength() const
{
    if (length() > INT_MAX)
        throw SBufTooBigException(__FILE__, __LINE__);
    return (int)length();
}

/**
 * obtains a char* to the beginning of this SBuf in memory.
 * \note the obtained string is NOT null-terminated.
 */
char *
SBuf::buf() const
{
    return store_->mem+off_;
}

/** returns the pointer to the first char after this SBuf end
 *
 *  No checks are made that the space returned is safe, checking that is
 *  up to the caller.
 */
char *
SBuf::bufEnd() const
{
    return store_->mem+off_+len_;
}

/**
 * copy-on-write: make sure that we are the only holder of the backing store.
 * If not, reallocate. If a new size is specified, and it is greater than the
 * current length, the backing store will be extended as needed
 * \retval false no grow was needed
 * \retval true had to copy
 */
bool
SBuf::cow(SBuf::size_type newsize)
{
    debugs(24, DBG_DATA, "new size:" << newsize);
    if (newsize == npos || newsize < length())
        newsize = length();

    if (store_->LockCount() == 1 && newsize == length()) {
        debugs(24, DBG_DATA, "no cow needed");
        ++stats.cowFast;
        return false;
    }
    reAlloc(newsize);
    return true;
}

/**
 * Try to guesstimate how big a MemBlob to allocate.
 * The result is guarranteed to be to be at least the desired
 * size.
 */
const SBuf::size_type
SBuf::estimateCapacity(SBuf::size_type desired) const
{
    return 2*desired;
}

/**
 * To be called after having determined that the buffers are equal up to the
 * length of the shortest one.
 * If the buffers' length is the same, then they're equal. Otherwise, the
 * longest one is deemed to be greater than the other.
 * This matches the behavior of strcmp(1) and strcasecmp(1)
 */
int
SBuf::commonCompareChecksPost(const SBuf &S) const
{
    if (length() == S.length()) //I'll be damned..they're REALLY the same..
        return 0;
    if (length() > S.length())
        return 1;
    return -1;
}

/** obtain prototype store
 *
 * Just-created SBufs all share to the same MemBlob.
 * This call instantiates and returns it.
 */
MemBlob::Pointer
SBuf::GetStorePrototype()
{
    static MemBlob::Pointer InitialStore = NULL;
    if (InitialStore == NULL) {
        static char lowPrototype[] = "";
        InitialStore = new MemBlob(lowPrototype, 0);
    }
    return InitialStore;
}

const char
SBuf::operator [](SBuf::size_type pos) const
{
    ++stats.getChar;
    return store_->mem[off_+pos];
}

const char
SBuf::at(SBuf::size_type pos) const
{
    checkAccessBounds(pos);
    return operator[](pos);
}

bool
SBuf::isEmpty() const
{
    return (len_ == 0);
}

std::ostream &
operator <<(std::ostream& os, const SBuf& S)
{
    return S.print(os);
}
